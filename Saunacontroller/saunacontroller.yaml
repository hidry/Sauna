esphome:
  name: "saunacontroller"
  friendly_name: "saunacontroller"
  on_boot:
    priority: -100
    then:
      - climate.control:
          id: sauna_thermostat
          mode: "OFF"
      # LED Standard-Farbe auf Lava-Rot setzen (ohne einzuschalten)
      # Farbe wird kurz gesetzt und sofort ausgeschaltet - Farbwerte bleiben gespeichert
      # Beim späteren Einschalten erscheint automatisch Lava-Rot
      - light.turn_on:
          id: led_salzkristall
          red: 100%
          green: 15%
          blue: 0%
          brightness: 100%
          transition_length: 0s
      - light.turn_off:
          id: led_salzkristall
          transition_length: 0s
      - light.turn_on:
          id: led_streifen
          red: 100%
          green: 15%
          blue: 0%
          brightness: 100%
          transition_length: 0s
      - light.turn_off:
          id: led_streifen
          transition_length: 0s
      # Shutdown-Log: Reset-Grund erkennen und protokollieren
      - lambda: |-
          #include "esp_system.h"
          esp_reset_reason_t reason = esp_reset_reason();
          // ESP_RST_TASK_WDT = 5 (Task Watchdog Reset)
          // ESP_RST_INT_WDT = 4 (Interrupt Watchdog Reset)
          if (reason == ESP_RST_TASK_WDT || reason == ESP_RST_INT_WDT) {
            ESP_LOGE("boot", "!!! TASK WATCHDOG RESET erkannt - ESP32 war blockiert !!!");
            id(log_shutdown_task_watchdog).execute();
          } else {
            // Normaler Boot (Power-On, Software-Reset, etc.)
            id(log_shutdown_boot).execute();
          }

esp32:
  board: esp32dev
  framework:
    type: arduino

# Example configuration entry
debug:
  update_interval: 5s

logger:
  level: info

# Enable Home Assistant API
api:
  encryption:
    key: !secret api_encryption_key

ota:
  platform: esphome
  password: !secret ota_password

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: !secret saunacontroller_ap_ssid
    password: !secret saunacontroller_ap_password

web_server:
  port: 80
  version: 3
  auth:
    username: !secret saunacontroller_webserver_user
    password: !secret saunacontroller_webserver_password
  sorting_groups:
    - id: group_sauna
      name: "Sauna"
      sorting_weight: 10
    - id: group_verdampfer
      name: "Verdampfer"
      sorting_weight: 20
    - id: group_infrarot
      name: "Infrarot"
      sorting_weight: 30
    - id: group_beleuchtung
      name: "Beleuchtung"
      sorting_weight: 40
    - id: group_statistik
      name: "Statistik"
      sorting_weight: 45
    - id: group_system
      name: "System"
      sorting_weight: 50

captive_portal:

# Shutdown-Log Scripts für Protokollierung der Abschaltgründe
# Grund-Codes: 1=BOOT, 2=AUTO_OFF_4H, 3=SSR_UEBERTEMP,
#              4=SAUNA_UEBERTEMP, 5=SHT30_AUSFALL, 6=DS18B20_AUSFALL, 7=TASK_WATCHDOG
script:
  - id: log_shutdown_boot
    then:
      - lambda: |-
          int idx = id(shutdown_log_index);
          int uptime_sec = millis() / 1000;
          switch(idx) {
            case 0: id(shutdown_log_0_reason) = 1; id(shutdown_log_0_uptime) = uptime_sec; break;
            case 1: id(shutdown_log_1_reason) = 1; id(shutdown_log_1_uptime) = uptime_sec; break;
            case 2: id(shutdown_log_2_reason) = 1; id(shutdown_log_2_uptime) = uptime_sec; break;
            case 3: id(shutdown_log_3_reason) = 1; id(shutdown_log_3_uptime) = uptime_sec; break;
            case 4: id(shutdown_log_4_reason) = 1; id(shutdown_log_4_uptime) = uptime_sec; break;
            case 5: id(shutdown_log_5_reason) = 1; id(shutdown_log_5_uptime) = uptime_sec; break;
            case 6: id(shutdown_log_6_reason) = 1; id(shutdown_log_6_uptime) = uptime_sec; break;
            case 7: id(shutdown_log_7_reason) = 1; id(shutdown_log_7_uptime) = uptime_sec; break;
            case 8: id(shutdown_log_8_reason) = 1; id(shutdown_log_8_uptime) = uptime_sec; break;
            case 9: id(shutdown_log_9_reason) = 1; id(shutdown_log_9_uptime) = uptime_sec; break;
          }
          id(shutdown_log_index) = (idx + 1) % 10;
          ESP_LOGI("shutdown_log", "BOOT protokolliert (Uptime: %ds)", uptime_sec);
  - id: log_shutdown_auto_off_4h
    then:
      - lambda: |-
          int idx = id(shutdown_log_index);
          int uptime_sec = millis() / 1000;
          switch(idx) {
            case 0: id(shutdown_log_0_reason) = 2; id(shutdown_log_0_uptime) = uptime_sec; break;
            case 1: id(shutdown_log_1_reason) = 2; id(shutdown_log_1_uptime) = uptime_sec; break;
            case 2: id(shutdown_log_2_reason) = 2; id(shutdown_log_2_uptime) = uptime_sec; break;
            case 3: id(shutdown_log_3_reason) = 2; id(shutdown_log_3_uptime) = uptime_sec; break;
            case 4: id(shutdown_log_4_reason) = 2; id(shutdown_log_4_uptime) = uptime_sec; break;
            case 5: id(shutdown_log_5_reason) = 2; id(shutdown_log_5_uptime) = uptime_sec; break;
            case 6: id(shutdown_log_6_reason) = 2; id(shutdown_log_6_uptime) = uptime_sec; break;
            case 7: id(shutdown_log_7_reason) = 2; id(shutdown_log_7_uptime) = uptime_sec; break;
            case 8: id(shutdown_log_8_reason) = 2; id(shutdown_log_8_uptime) = uptime_sec; break;
            case 9: id(shutdown_log_9_reason) = 2; id(shutdown_log_9_uptime) = uptime_sec; break;
          }
          id(shutdown_log_index) = (idx + 1) % 10;
          ESP_LOGW("shutdown_log", "AUTO_OFF_4H protokolliert (Uptime: %ds)", uptime_sec);
  - id: log_shutdown_ssr_uebertemp
    then:
      - lambda: |-
          int idx = id(shutdown_log_index);
          int uptime_sec = millis() / 1000;
          switch(idx) {
            case 0: id(shutdown_log_0_reason) = 3; id(shutdown_log_0_uptime) = uptime_sec; break;
            case 1: id(shutdown_log_1_reason) = 3; id(shutdown_log_1_uptime) = uptime_sec; break;
            case 2: id(shutdown_log_2_reason) = 3; id(shutdown_log_2_uptime) = uptime_sec; break;
            case 3: id(shutdown_log_3_reason) = 3; id(shutdown_log_3_uptime) = uptime_sec; break;
            case 4: id(shutdown_log_4_reason) = 3; id(shutdown_log_4_uptime) = uptime_sec; break;
            case 5: id(shutdown_log_5_reason) = 3; id(shutdown_log_5_uptime) = uptime_sec; break;
            case 6: id(shutdown_log_6_reason) = 3; id(shutdown_log_6_uptime) = uptime_sec; break;
            case 7: id(shutdown_log_7_reason) = 3; id(shutdown_log_7_uptime) = uptime_sec; break;
            case 8: id(shutdown_log_8_reason) = 3; id(shutdown_log_8_uptime) = uptime_sec; break;
            case 9: id(shutdown_log_9_reason) = 3; id(shutdown_log_9_uptime) = uptime_sec; break;
          }
          id(shutdown_log_index) = (idx + 1) % 10;
          ESP_LOGW("shutdown_log", "SSR_UEBERTEMP protokolliert (Uptime: %ds)", uptime_sec);
  - id: log_shutdown_sauna_uebertemp
    then:
      - lambda: |-
          int idx = id(shutdown_log_index);
          int uptime_sec = millis() / 1000;
          switch(idx) {
            case 0: id(shutdown_log_0_reason) = 4; id(shutdown_log_0_uptime) = uptime_sec; break;
            case 1: id(shutdown_log_1_reason) = 4; id(shutdown_log_1_uptime) = uptime_sec; break;
            case 2: id(shutdown_log_2_reason) = 4; id(shutdown_log_2_uptime) = uptime_sec; break;
            case 3: id(shutdown_log_3_reason) = 4; id(shutdown_log_3_uptime) = uptime_sec; break;
            case 4: id(shutdown_log_4_reason) = 4; id(shutdown_log_4_uptime) = uptime_sec; break;
            case 5: id(shutdown_log_5_reason) = 4; id(shutdown_log_5_uptime) = uptime_sec; break;
            case 6: id(shutdown_log_6_reason) = 4; id(shutdown_log_6_uptime) = uptime_sec; break;
            case 7: id(shutdown_log_7_reason) = 4; id(shutdown_log_7_uptime) = uptime_sec; break;
            case 8: id(shutdown_log_8_reason) = 4; id(shutdown_log_8_uptime) = uptime_sec; break;
            case 9: id(shutdown_log_9_reason) = 4; id(shutdown_log_9_uptime) = uptime_sec; break;
          }
          id(shutdown_log_index) = (idx + 1) % 10;
          ESP_LOGW("shutdown_log", "SAUNA_UEBERTEMP protokolliert (Uptime: %ds)", uptime_sec);
  - id: log_shutdown_sht30_ausfall
    then:
      - lambda: |-
          int idx = id(shutdown_log_index);
          int uptime_sec = millis() / 1000;
          switch(idx) {
            case 0: id(shutdown_log_0_reason) = 5; id(shutdown_log_0_uptime) = uptime_sec; break;
            case 1: id(shutdown_log_1_reason) = 5; id(shutdown_log_1_uptime) = uptime_sec; break;
            case 2: id(shutdown_log_2_reason) = 5; id(shutdown_log_2_uptime) = uptime_sec; break;
            case 3: id(shutdown_log_3_reason) = 5; id(shutdown_log_3_uptime) = uptime_sec; break;
            case 4: id(shutdown_log_4_reason) = 5; id(shutdown_log_4_uptime) = uptime_sec; break;
            case 5: id(shutdown_log_5_reason) = 5; id(shutdown_log_5_uptime) = uptime_sec; break;
            case 6: id(shutdown_log_6_reason) = 5; id(shutdown_log_6_uptime) = uptime_sec; break;
            case 7: id(shutdown_log_7_reason) = 5; id(shutdown_log_7_uptime) = uptime_sec; break;
            case 8: id(shutdown_log_8_reason) = 5; id(shutdown_log_8_uptime) = uptime_sec; break;
            case 9: id(shutdown_log_9_reason) = 5; id(shutdown_log_9_uptime) = uptime_sec; break;
          }
          id(shutdown_log_index) = (idx + 1) % 10;
          ESP_LOGW("shutdown_log", "SHT30_AUSFALL protokolliert (Uptime: %ds)", uptime_sec);
  - id: log_shutdown_ds18b20_ausfall
    then:
      - lambda: |-
          int idx = id(shutdown_log_index);
          int uptime_sec = millis() / 1000;
          switch(idx) {
            case 0: id(shutdown_log_0_reason) = 6; id(shutdown_log_0_uptime) = uptime_sec; break;
            case 1: id(shutdown_log_1_reason) = 6; id(shutdown_log_1_uptime) = uptime_sec; break;
            case 2: id(shutdown_log_2_reason) = 6; id(shutdown_log_2_uptime) = uptime_sec; break;
            case 3: id(shutdown_log_3_reason) = 6; id(shutdown_log_3_uptime) = uptime_sec; break;
            case 4: id(shutdown_log_4_reason) = 6; id(shutdown_log_4_uptime) = uptime_sec; break;
            case 5: id(shutdown_log_5_reason) = 6; id(shutdown_log_5_uptime) = uptime_sec; break;
            case 6: id(shutdown_log_6_reason) = 6; id(shutdown_log_6_uptime) = uptime_sec; break;
            case 7: id(shutdown_log_7_reason) = 6; id(shutdown_log_7_uptime) = uptime_sec; break;
            case 8: id(shutdown_log_8_reason) = 6; id(shutdown_log_8_uptime) = uptime_sec; break;
            case 9: id(shutdown_log_9_reason) = 6; id(shutdown_log_9_uptime) = uptime_sec; break;
          }
          id(shutdown_log_index) = (idx + 1) % 10;
          ESP_LOGW("shutdown_log", "DS18B20_AUSFALL protokolliert (Uptime: %ds)", uptime_sec);
  - id: log_shutdown_task_watchdog
    then:
      - lambda: |-
          int idx = id(shutdown_log_index);
          int uptime_sec = millis() / 1000;
          switch(idx) {
            case 0: id(shutdown_log_0_reason) = 7; id(shutdown_log_0_uptime) = uptime_sec; break;
            case 1: id(shutdown_log_1_reason) = 7; id(shutdown_log_1_uptime) = uptime_sec; break;
            case 2: id(shutdown_log_2_reason) = 7; id(shutdown_log_2_uptime) = uptime_sec; break;
            case 3: id(shutdown_log_3_reason) = 7; id(shutdown_log_3_uptime) = uptime_sec; break;
            case 4: id(shutdown_log_4_reason) = 7; id(shutdown_log_4_uptime) = uptime_sec; break;
            case 5: id(shutdown_log_5_reason) = 7; id(shutdown_log_5_uptime) = uptime_sec; break;
            case 6: id(shutdown_log_6_reason) = 7; id(shutdown_log_6_uptime) = uptime_sec; break;
            case 7: id(shutdown_log_7_reason) = 7; id(shutdown_log_7_uptime) = uptime_sec; break;
            case 8: id(shutdown_log_8_reason) = 7; id(shutdown_log_8_uptime) = uptime_sec; break;
            case 9: id(shutdown_log_9_reason) = 7; id(shutdown_log_9_uptime) = uptime_sec; break;
          }
          id(shutdown_log_index) = (idx + 1) % 10;
          ESP_LOGE("shutdown_log", "TASK_WATCHDOG protokolliert (Uptime: %ds)", uptime_sec);

switch:
  - platform: gpio
    id: saunaofen
    pin: GPIO16
    restore_mode: ALWAYS_OFF
    internal: true
    on_turn_on:
      - lambda: |-
          id(ofen_start_ms) = millis();
    on_turn_off:
      - lambda: |-
          if (id(ofen_start_ms) > 0) {
            unsigned long duration_ms = millis() - id(ofen_start_ms);
            id(ofen_betriebsstunden) += duration_ms / 3600000.0f;
            id(ofen_start_ms) = 0;
          }
  - platform: gpio
    id: saunaverdampfer
    pin: GPIO17
    restore_mode: ALWAYS_OFF
    internal: true
    on_turn_on:
      - lambda: |-
          id(verdampfer_start_ms) = millis();
    on_turn_off:
      - lambda: |-
          if (id(verdampfer_start_ms) > 0) {
            unsigned long duration_ms = millis() - id(verdampfer_start_ms);
            id(verdampfer_betriebsstunden) += duration_ms / 3600000.0f;
            id(verdampfer_start_ms) = 0;
          }
  - platform: restart
    name: "ESP Restart"
    web_server:
      sorting_group_id: group_system
      sorting_weight: 10
  - platform: template
    id: hygrostat_switch
    name: "Hygrostat"
    icon: "mdi:water-percent"
    restore_mode: ALWAYS_OFF
    web_server:
      sorting_group_id: group_verdampfer
      sorting_weight: 10
    lambda: |-
      return id(hygrostat_active);
    turn_on_action:
      - globals.set:
          id: hygrostat_active
          value: 'true'
      - lambda: |-
          // Sauna-Session starten falls noch nicht aktiv
          if (!id(sauna_session_active)) {
            id(sauna_sessions) += 1;
            id(sauna_session_active) = true;
          }
    turn_off_action:
      - globals.set:
          id: hygrostat_active
          value: 'false'
      - switch.turn_off: saunaverdampfer
      - lambda: |-
          // Sauna-Session beenden falls Thermostat auch aus
          if (id(sauna_session_active) && id(sauna_thermostat).mode == climate::CLIMATE_MODE_OFF) {
            id(sauna_session_active) = false;
          }

binary_sensor:
  # SSR-Sicherheit: Übertemperatur-Warnung für Schaltschrank
  # Schützt SSRs, Elektronik und Holzständerhaus vor Überhitzung
  - platform: template
    id: schaltschrank_uebertemperatur
    name: "Schaltschrank Übertemperatur"
    device_class: heat
    icon: "mdi:thermometer-alert"
    web_server:
      sorting_group_id: group_system
      sorting_weight: 15
    lambda: |-
      if (!id(temperatur_steuergeraet).has_state()) {
        return false;
      }
      float temp = id(temperatur_steuergeraet).state;
      // Hysterese: ON bei >50°C, OFF bei <45°C
      if (temp > 50.0) {
        return true;
      } else if (temp < 45.0) {
        return false;
      }
      // Zwischen 45-50°C: Zustand beibehalten
      return id(schaltschrank_uebertemperatur).state;

  # SSR-Sicherheit: Notabschaltung wurde ausgelöst
  - platform: template
    id: ssr_notabschaltung
    name: "SSR Notabschaltung aktiv"
    device_class: problem
    icon: "mdi:alert-octagon"
    web_server:
      sorting_group_id: group_system
      sorting_weight: 16
    lambda: |-
      return id(ssr_notabschaltung_aktiv);

  # Sauna-Sicherheit: Übertemperatur-Warnung für Sauna-Raum
  # Schützt vor Reglerversagen und zu hohen Temperaturen
  - platform: template
    id: sauna_uebertemperatur
    name: "Sauna Übertemperatur"
    device_class: heat
    icon: "mdi:thermometer-alert"
    web_server:
      sorting_group_id: group_sauna
      sorting_weight: 25
    lambda: |-
      if (!id(temperatur_sauna).has_state()) {
        return false;
      }
      float temp = id(temperatur_sauna).state;
      // Hysterese: ON bei >90°C, OFF bei <85°C
      if (temp > 90.0) {
        return true;
      } else if (temp < 85.0) {
        return false;
      }
      // Zwischen 85-90°C: Zustand beibehalten
      return id(sauna_uebertemperatur).state;

  # Sauna-Sicherheit: Notabschaltung wurde ausgelöst
  - platform: template
    id: sauna_notabschaltung
    name: "Sauna Notabschaltung aktiv"
    device_class: problem
    icon: "mdi:alert-octagon"
    web_server:
      sorting_group_id: group_sauna
      sorting_weight: 26
    lambda: |-
      return id(sauna_notabschaltung_aktiv);

  # Sensor-Ausfall Erkennung: SHT30 Temperatursensor liefert keine Werte
  # Schützt vor defekten oder abgesteckten Sensoren
  - platform: template
    id: sensor_ausfall
    name: "Temperatursensor Ausfall"
    device_class: problem
    icon: "mdi:thermometer-off"
    web_server:
      sorting_group_id: group_system
      sorting_weight: 17
    lambda: |-
      return id(sensor_ausfall_aktiv);

  # Sensor-Ausfall Erkennung: DS18B20 Schaltschrank-Sensor liefert keine Werte
  # Schützt vor defekten oder abgesteckten Sensoren - kritisch für SSR-Sicherheit
  - platform: template
    id: ds18b20_ausfall
    name: "Schaltschrank-Sensor Ausfall"
    device_class: problem
    icon: "mdi:thermometer-off"
    web_server:
      sorting_group_id: group_system
      sorting_weight: 18
    lambda: |-
      return id(ds18b20_ausfall_aktiv);

  # CPU-Überlastungs-Warnung: Loop Time >100ms deutet auf blockierende Operationen
  # Frühwarnung vor Task Watchdog Reset (tritt bei ~15s blockierter Loop auf)
  - platform: template
    id: cpu_ueberlastet
    name: "CPU Überlastet"
    device_class: problem
    icon: "mdi:cpu-32-bit"
    web_server:
      sorting_group_id: group_system
      sorting_weight: 19
    lambda: |-
      if (!id(loop_time_sensor).has_state()) {
        return false;
      }
      float loop_ms = id(loop_time_sensor).state;
      // Warnung bei >100ms Loop Time (deutet auf blockierende I2C/WiFi-Operationen)
      // Task Watchdog schlägt bei ~15000ms zu, >100ms ist Frühwarnung
      if (loop_ms > 100.0) {
        return true;
      } else if (loop_ms < 50.0) {
        return false;
      }
      // Zwischen 50-100ms: Zustand beibehalten (Hysterese)
      return id(cpu_ueberlastet).state;

one_wire:
  - pin: GPIO23
    platform: gpio
    #update_interval: 30s
    id: "temperature_hub"

# Temperatur / Luftfeuchtesensor müssen angeschlossen sein, sonst kein Booten möglich: Recovery failed, SCL is held low on the bus
i2c:
  - id: i2c_bus_a
    sda: GPIO33
    scl: GPIO32
    scan: False
    frequency: 50kHz  # Reduziert von Standard 100kHz für bessere EMI-Resistenz
    timeout: 100ms    # Erhöht auf 100ms um Task Watchdog durch hängenden Sensor zu vermeiden

sensor:
  - platform: dallas_temp
    id: temperatur_steuergeraet
    address: 0x4a3c01b607ccd828
    name: "Temperatur Steuergerät"
    web_server:
      sorting_group_id: group_system
      sorting_weight: 20
    on_value:
      then:
        - lambda: |-
            id(letzter_ds18b20_update) = millis();
  - platform: sht3xd
    i2c_id: i2c_bus_a
    address: 0x44
    temperature:
      id: temperatur_sauna
      name: "Temperatur Sauna"
      accuracy_decimals: 1
      web_server:
        sorting_group_id: group_sauna
        sorting_weight: 20
      on_value:
        then:
          - lambda: |-
              id(letzter_temperatur_update) = millis();
    humidity:
      id: luftfeuchte_sauna
      name: "Luftfeuchte Sauna"
      accuracy_decimals: 1
      web_server:
        sorting_group_id: group_verdampfer
        sorting_weight: 30
    update_interval: 30s
  - platform: uptime
    type: seconds
    name: "Uptime Sensor"
    web_server:
      sorting_group_id: group_system
      sorting_weight: 30
  - platform: debug
    free:
      name: "Heap Free"
      web_server:
        sorting_group_id: group_system
        sorting_weight: 40
    block:
      name: "Heap Max Block"
      web_server:
        sorting_group_id: group_system
        sorting_weight: 50
    loop_time:
      id: loop_time_sensor
      name: "Loop Time"
      web_server:
        sorting_group_id: group_system
        sorting_weight: 60
  # Auto-Off Restzeit (aus main)
  - platform: template
    id: sauna_restzeit
    name: "Sauna Restzeit"
    unit_of_measurement: "min"
    icon: "mdi:timer-outline"
    accuracy_decimals: 0
    update_interval: 10s
    web_server:
      sorting_group_id: group_sauna
      sorting_weight: 15
    lambda: |-
      if (id(sauna_session_start_time) == 0) {
        return 0;
      }
      unsigned long elapsed = millis() - id(sauna_session_start_time);
      unsigned long max_time = 4UL * 60 * 60 * 1000;  // 4h in ms
      if (elapsed >= max_time) {
        return 0;
      }
      return (max_time - elapsed) / 60000.0;  // Minuten
  # Infrarot Auto-Off Restzeit
  - platform: template
    id: infrarot1_restzeit
    name: "Infrarot 1 Restzeit"
    unit_of_measurement: "min"
    icon: "mdi:timer-outline"
    accuracy_decimals: 0
    update_interval: 10s
    web_server:
      sorting_group_id: group_infrarot
      sorting_weight: 15
    lambda: |-
      if (id(infrarot1_start_ms) == 0) {
        return 0;
      }
      unsigned long elapsed = millis() - id(infrarot1_start_ms);
      unsigned long max_time = 2UL * 60 * 60 * 1000;  // 2h in ms
      if (elapsed >= max_time) {
        return 0;
      }
      return (max_time - elapsed) / 60000.0;  // Minuten
  - platform: template
    id: infrarot2_restzeit
    name: "Infrarot 2 Restzeit"
    unit_of_measurement: "min"
    icon: "mdi:timer-outline"
    accuracy_decimals: 0
    update_interval: 10s
    web_server:
      sorting_group_id: group_infrarot
      sorting_weight: 25
    lambda: |-
      if (id(infrarot2_start_ms) == 0) {
        return 0;
      }
      unsigned long elapsed = millis() - id(infrarot2_start_ms);
      unsigned long max_time = 2UL * 60 * 60 * 1000;  // 2h in ms
      if (elapsed >= max_time) {
        return 0;
      }
      return (max_time - elapsed) / 60000.0;  // Minuten
  # Session-Zähler
  - platform: template
    name: "Sauna Sessions"
    id: sensor_sauna_sessions
    icon: "mdi:counter"
    accuracy_decimals: 0
    lambda: |-
      return id(sauna_sessions);
    update_interval: 60s
    web_server:
      sorting_group_id: group_statistik
      sorting_weight: 10
  - platform: template
    name: "Infrarot 1 Sessions"
    id: sensor_infrarot1_sessions
    icon: "mdi:counter"
    accuracy_decimals: 0
    lambda: |-
      return id(infrarot1_sessions);
    update_interval: 60s
    web_server:
      sorting_group_id: group_statistik
      sorting_weight: 20
  - platform: template
    name: "Infrarot 2 Sessions"
    id: sensor_infrarot2_sessions
    icon: "mdi:counter"
    accuracy_decimals: 0
    lambda: |-
      return id(infrarot2_sessions);
    update_interval: 60s
    web_server:
      sorting_group_id: group_statistik
      sorting_weight: 30
  # Betriebsstunden-Zähler
  - platform: template
    name: "Ofen Betriebsstunden"
    id: sensor_ofen_betriebsstunden
    icon: "mdi:clock-outline"
    unit_of_measurement: "h"
    accuracy_decimals: 1
    lambda: |-
      return id(ofen_betriebsstunden);
    update_interval: 60s
    web_server:
      sorting_group_id: group_statistik
      sorting_weight: 40
  - platform: template
    name: "Verdampfer Betriebsstunden"
    id: sensor_verdampfer_betriebsstunden
    icon: "mdi:clock-outline"
    unit_of_measurement: "h"
    accuracy_decimals: 1
    lambda: |-
      return id(verdampfer_betriebsstunden);
    update_interval: 60s
    web_server:
      sorting_group_id: group_statistik
      sorting_weight: 50
  - platform: template
    name: "Infrarot 1 Betriebsstunden"
    id: sensor_infrarot1_betriebsstunden
    icon: "mdi:clock-outline"
    unit_of_measurement: "h"
    accuracy_decimals: 1
    lambda: |-
      return id(infrarot1_betriebsstunden);
    update_interval: 60s
    web_server:
      sorting_group_id: group_statistik
      sorting_weight: 60
  - platform: template
    name: "Infrarot 2 Betriebsstunden"
    id: sensor_infrarot2_betriebsstunden
    icon: "mdi:clock-outline"
    unit_of_measurement: "h"
    accuracy_decimals: 1
    lambda: |-
      return id(infrarot2_betriebsstunden);
    update_interval: 60s
    web_server:
      sorting_group_id: group_statistik
      sorting_weight: 70
  - platform: template
    name: "LED Salzkristall Betriebsstunden"
    id: sensor_led_salzkristall_betriebsstunden
    icon: "mdi:clock-outline"
    unit_of_measurement: "h"
    accuracy_decimals: 1
    lambda: |-
      return id(led_salzkristall_betriebsstunden);
    update_interval: 60s
    web_server:
      sorting_group_id: group_statistik
      sorting_weight: 80
  - platform: template
    name: "LED Streifen Betriebsstunden"
    id: sensor_led_streifen_betriebsstunden
    icon: "mdi:clock-outline"
    unit_of_measurement: "h"
    accuracy_decimals: 1
    lambda: |-
      return id(led_streifen_betriebsstunden);
    update_interval: 60s
    web_server:
      sorting_group_id: group_statistik
      sorting_weight: 90

#LED Stripes - GPI02 & GPIO15
light:
  - platform: monochromatic
    id: infrarot1
    output: gpio_18
    name: "Infrarotstrahler 1"
    web_server:
      sorting_group_id: group_infrarot
      sorting_weight: 10
    on_turn_on:
      - lambda: |-
          id(infrarot1_start_ms) = millis();
          id(infrarot1_sessions) += 1;
    on_turn_off:
      - lambda: |-
          if (id(infrarot1_start_ms) > 0) {
            unsigned long duration_ms = millis() - id(infrarot1_start_ms);
            id(infrarot1_betriebsstunden) += duration_ms / 3600000.0f;
            id(infrarot1_start_ms) = 0;
          }
  - platform: monochromatic
    id: infrarot2
    output: gpio_19
    name: "Infrarotstrahler 2"
    web_server:
      sorting_group_id: group_infrarot
      sorting_weight: 20
    on_turn_on:
      - lambda: |-
          id(infrarot2_start_ms) = millis();
          id(infrarot2_sessions) += 1;
    on_turn_off:
      - lambda: |-
          if (id(infrarot2_start_ms) > 0) {
            unsigned long duration_ms = millis() - id(infrarot2_start_ms);
            id(infrarot2_betriebsstunden) += duration_ms / 3600000.0f;
            id(infrarot2_start_ms) = 0;
          }
  - platform: esp32_rmt_led_strip
    id: led_salzkristall
    rgb_order: BGR
    pin: GPIO2
    num_leds: 16
    #rmt_channel: 0
    chipset: ws2812
    name: "LED Salzkristall-Leuchten"
    web_server:
      sorting_group_id: group_beleuchtung
      sorting_weight: 10
    on_turn_on:
      - lambda: |-
          id(led_salzkristall_start_ms) = millis();
    on_turn_off:
      - lambda: |-
          if (id(led_salzkristall_start_ms) > 0) {
            unsigned long duration_ms = millis() - id(led_salzkristall_start_ms);
            id(led_salzkristall_betriebsstunden) += duration_ms / 3600000.0f;
            id(led_salzkristall_start_ms) = 0;
          }
  - platform: esp32_rmt_led_strip
    id: led_streifen
    rgb_order: GRB
    pin: GPIO15
    num_leds: 213
    #rmt_channel: 1
    chipset: ws2812
    name: "LED Streifen"
    web_server:
      sorting_group_id: group_beleuchtung
      sorting_weight: 20
    on_turn_on:
      - lambda: |-
          id(led_streifen_start_ms) = millis();
    on_turn_off:
      - lambda: |-
          if (id(led_streifen_start_ms) > 0) {
            unsigned long duration_ms = millis() - id(led_streifen_start_ms);
            id(led_streifen_betriebsstunden) += duration_ms / 3600000.0f;
            id(led_streifen_start_ms) = 0;
          }
  #   effects:
  #     - pulse:
  #         name: "Fast Pulse"
  #         transition_length: 0.5s
  #         update_interval: 0.5s
  #         min_brightness: 0%
  #         max_brightness: 100%
  #     - random:
  #         name: Random Effect With Custom Values
  #         transition_length: 5s
  #         update_interval: 7s
  #     - strobe:
  #         name: Strobe Effect With Custom Values
  #         colors:
  #           - state: true
  #             brightness: 100%
  #             red: 100%
  #             green: 90%
  #             blue: 0%
  #             duration: 500ms
  #           - state: false
  #             duration: 250ms
  #           - state: true
  #             brightness: 100%
  #             red: 0%
  #             green: 100%
  #             blue: 0%
  #             duration: 500ms
  #     - flicker:
  #         name: Flicker Effect With Custom Values
  #         alpha: 95%
  #         intensity: 1.5%
  #     - addressable_rainbow:
  #         name: Rainbow Effect With Custom Values
  #         speed: 10
  #         width: 50

#Infrarotstrahler - GPIO18 / GPIO19
output:
  - platform: ac_dimmer
    gate_pin: GPIO18
    id: gpio_18
    zero_cross_pin:
      number: GPIO5
      mode:
        input: true
      inverted: yes
      allow_other_uses: true
  - platform: ac_dimmer
    gate_pin: GPIO19
    id: gpio_19
    zero_cross_pin:
      number: GPIO5
      mode:
        input: true
      inverted: yes
      allow_other_uses: true

text_sensor:
  # Shutdown-Log: Zeigt die letzten 10 Abschaltungen mit Grund und Uptime
  - platform: template
    id: shutdown_log_display
    name: "Abschaltungs-Log"
    icon: "mdi:history"
    update_interval: 60s
    web_server:
      sorting_group_id: group_system
      sorting_weight: 12
    lambda: |-
      // Reason-Code zu lesbarem Text
      auto reason_text = [](int reason) -> const char* {
        switch(reason) {
          case 1: return "BOOT";
          case 2: return "AUTO_OFF_4H";
          case 3: return "SSR_UEBERTEMP";
          case 4: return "SAUNA_UEBERTEMP";
          case 5: return "SHT30_AUSFALL";
          case 6: return "DS18B20_AUSFALL";
          case 7: return "TASK_WATCHDOG";
          default: return "";
        }
      };

      // Uptime formatieren (Sekunden -> "Xh XXm")
      auto format_uptime = [](int seconds) -> std::string {
        int hours = seconds / 3600;
        int minutes = (seconds % 3600) / 60;
        char buf[16];
        snprintf(buf, sizeof(buf), "%dh %02dm", hours, minutes);
        return std::string(buf);
      };

      // Alle 10 Einträge in Arrays sammeln (für Ringpuffer-Sortierung)
      int reasons[10] = {
        id(shutdown_log_0_reason), id(shutdown_log_1_reason),
        id(shutdown_log_2_reason), id(shutdown_log_3_reason),
        id(shutdown_log_4_reason), id(shutdown_log_5_reason),
        id(shutdown_log_6_reason), id(shutdown_log_7_reason),
        id(shutdown_log_8_reason), id(shutdown_log_9_reason)
      };
      int uptimes[10] = {
        id(shutdown_log_0_uptime), id(shutdown_log_1_uptime),
        id(shutdown_log_2_uptime), id(shutdown_log_3_uptime),
        id(shutdown_log_4_uptime), id(shutdown_log_5_uptime),
        id(shutdown_log_6_uptime), id(shutdown_log_7_uptime),
        id(shutdown_log_8_uptime), id(shutdown_log_9_uptime)
      };

      std::string result = "";
      int current_idx = id(shutdown_log_index);
      int count = 0;

      // Vom neuesten zum ältesten Eintrag iterieren
      for (int i = 0; i < 10; i++) {
        int idx = (current_idx - 1 - i + 10) % 10;
        if (reasons[idx] != 0) {
          if (count > 0) result += "\n";
          result += "[" + format_uptime(uptimes[idx]) + "] ";
          result += reason_text(reasons[idx]);
          count++;
        }
      }

      if (count == 0) {
        return std::string("Keine Einträge");
      }
      return result;
  - platform: version
    name: "ESPHome Version"
    web_server:
      sorting_group_id: group_system
      sorting_weight: 70
  - platform: debug
    device:
      name: "Device Info"
      web_server:
        sorting_group_id: group_system
        sorting_weight: 80
    reset_reason:
      name: "Reset Reason"
      web_server:
        sorting_group_id: group_system
        sorting_weight: 90

# Standalone Sauna Controller (ohne Home Assistant)
climate:
  - platform: thermostat
    id: sauna_thermostat
    name: "Sauna Thermostat"
    sensor: temperatur_sauna
    default_preset: Home
    on_boot_restore_from: default_preset
    preset:
      - name: Home
        default_target_temperature_low: 80
    min_heating_off_time: 0s
    min_heating_run_time: 0s
    min_idle_time: 0s
    heat_deadband: 3.0
    heat_overrun: 3.0
    visual:
      min_temperature: 20
      max_temperature: 90
      temperature_step: 1.0
    heat_action:
      - switch.turn_on: saunaofen
    idle_action:
      - switch.turn_off: saunaofen
    on_control:
      - lambda: |-
          // Sauna-Session Logik bei Thermostat-Steuerung
          if (id(sauna_thermostat).mode != climate::CLIMATE_MODE_OFF) {
            // Thermostat wurde aktiviert
            if (!id(sauna_session_active)) {
              id(sauna_sessions) += 1;
              id(sauna_session_active) = true;
            }
          } else {
            // Thermostat wurde ausgeschaltet
            if (id(sauna_session_active) && !id(hygrostat_active)) {
              id(sauna_session_active) = false;
            }
          }
    startup_delay: true
    web_server:
      sorting_group_id: group_sauna
      sorting_weight: 10

number:
  - platform: template
    id: target_humidity
    name: "Ziel-Luftfeuchtigkeit"
    unit_of_measurement: "%"
    icon: "mdi:water-percent"
    min_value: 30
    max_value: 70
    step: 1
    initial_value: 50
    restore_value: true
    optimistic: true
    web_server:
      sorting_group_id: group_verdampfer
      sorting_weight: 20

  - platform: template
    id: hygrostat_dry_tolerance
    name: "Hygrostat Toleranz (trocken)"
    unit_of_measurement: "%"
    icon: "mdi:arrow-down"
    min_value: 1
    max_value: 10
    step: 1
    initial_value: 3
    restore_value: true
    optimistic: true
    web_server:
      sorting_group_id: group_verdampfer
      sorting_weight: 40

  - platform: template
    id: hygrostat_wet_tolerance
    name: "Hygrostat Toleranz (feucht)"
    unit_of_measurement: "%"
    icon: "mdi:arrow-up"
    min_value: 1
    max_value: 10
    step: 1
    initial_value: 3
    restore_value: true
    optimistic: true
    web_server:
      sorting_group_id: group_verdampfer
      sorting_weight: 50

globals:
  - id: hygrostat_active
    type: bool
    restore_value: false
    initial_value: 'false'
  # SSR-Sicherheit: Notabschaltung aktiv
  - id: ssr_notabschaltung_aktiv
    type: bool
    restore_value: false
    initial_value: 'false'
  # Sauna-Sicherheit: Notabschaltung bei Übertemperatur im Sauna-Raum
  - id: sauna_notabschaltung_aktiv
    type: bool
    restore_value: false
    initial_value: 'false'
  # Sensor-Ausfall Erkennung (SHT30 Sauna-Temperatur)
  - id: sensor_ausfall_aktiv
    type: bool
    restore_value: false
    initial_value: 'false'
  - id: letzter_temperatur_update
    type: unsigned long
    restore_value: false
    initial_value: '0'
  # Sensor-Ausfall Erkennung (DS18B20 Schaltschrank-Temperatur)
  - id: ds18b20_ausfall_aktiv
    type: bool
    restore_value: false
    initial_value: 'false'
  - id: letzter_ds18b20_update
    type: unsigned long
    restore_value: false
    initial_value: '0'
  # Sauna-Session Tracking
  - id: sauna_session_active
    type: bool
    restore_value: false
    initial_value: 'false'
  # Auto-Off Timer (aus main)
  - id: sauna_session_start_time
    type: unsigned long
    restore_value: false
    initial_value: '0'
  # Session-Zähler (persistent)
  - id: sauna_sessions
    type: int
    restore_value: true
    initial_value: '0'
  - id: infrarot1_sessions
    type: int
    restore_value: true
    initial_value: '0'
  - id: infrarot2_sessions
    type: int
    restore_value: true
    initial_value: '0'
  # Betriebsstunden (persistent, in Stunden)
  - id: ofen_betriebsstunden
    type: float
    restore_value: true
    initial_value: '0.0'
  - id: verdampfer_betriebsstunden
    type: float
    restore_value: true
    initial_value: '0.0'
  - id: infrarot1_betriebsstunden
    type: float
    restore_value: true
    initial_value: '0.0'
  - id: infrarot2_betriebsstunden
    type: float
    restore_value: true
    initial_value: '0.0'
  - id: led_salzkristall_betriebsstunden
    type: float
    restore_value: true
    initial_value: '0.0'
  - id: led_streifen_betriebsstunden
    type: float
    restore_value: true
    initial_value: '0.0'
  # Start-Timestamps für Zeitmessung (RAM-only, in ms)
  - id: ofen_start_ms
    type: unsigned long
    restore_value: false
    initial_value: '0'
  - id: verdampfer_start_ms
    type: unsigned long
    restore_value: false
    initial_value: '0'
  - id: infrarot1_start_ms
    type: unsigned long
    restore_value: false
    initial_value: '0'
  - id: infrarot2_start_ms
    type: unsigned long
    restore_value: false
    initial_value: '0'
  - id: led_salzkristall_start_ms
    type: unsigned long
    restore_value: false
    initial_value: '0'
  - id: led_streifen_start_ms
    type: unsigned long
    restore_value: false
    initial_value: '0'
  # Shutdown-Log: Ringpuffer für Abschaltungs-Protokollierung
  # Speichert die letzten 10 Abschaltungen mit Grund und Uptime
  # Grund-Codes: 0=LEER, 1=BOOT, 2=AUTO_OFF_4H, 3=SSR_UEBERTEMP,
  #              4=SAUNA_UEBERTEMP, 5=SHT30_AUSFALL, 6=DS18B20_AUSFALL, 7=TASK_WATCHDOG
  - id: shutdown_log_index
    type: int
    restore_value: true
    initial_value: '0'
  - id: shutdown_log_0_reason
    type: int
    restore_value: true
    initial_value: '0'
  - id: shutdown_log_0_uptime
    type: int
    restore_value: true
    initial_value: '0'
  - id: shutdown_log_1_reason
    type: int
    restore_value: true
    initial_value: '0'
  - id: shutdown_log_1_uptime
    type: int
    restore_value: true
    initial_value: '0'
  - id: shutdown_log_2_reason
    type: int
    restore_value: true
    initial_value: '0'
  - id: shutdown_log_2_uptime
    type: int
    restore_value: true
    initial_value: '0'
  - id: shutdown_log_3_reason
    type: int
    restore_value: true
    initial_value: '0'
  - id: shutdown_log_3_uptime
    type: int
    restore_value: true
    initial_value: '0'
  - id: shutdown_log_4_reason
    type: int
    restore_value: true
    initial_value: '0'
  - id: shutdown_log_4_uptime
    type: int
    restore_value: true
    initial_value: '0'
  - id: shutdown_log_5_reason
    type: int
    restore_value: true
    initial_value: '0'
  - id: shutdown_log_5_uptime
    type: int
    restore_value: true
    initial_value: '0'
  - id: shutdown_log_6_reason
    type: int
    restore_value: true
    initial_value: '0'
  - id: shutdown_log_6_uptime
    type: int
    restore_value: true
    initial_value: '0'
  - id: shutdown_log_7_reason
    type: int
    restore_value: true
    initial_value: '0'
  - id: shutdown_log_7_uptime
    type: int
    restore_value: true
    initial_value: '0'
  - id: shutdown_log_8_reason
    type: int
    restore_value: true
    initial_value: '0'
  - id: shutdown_log_8_uptime
    type: int
    restore_value: true
    initial_value: '0'
  - id: shutdown_log_9_reason
    type: int
    restore_value: true
    initial_value: '0'
  - id: shutdown_log_9_uptime
    type: int
    restore_value: true
    initial_value: '0'

interval:
  # Hygrostat-Regelung
  - interval: 10s
    then:
      - lambda: |-
          if (!id(hygrostat_active)) {
            return;
          }
          if (!id(luftfeuchte_sauna).has_state()) {
            return;
          }
          float current = id(luftfeuchte_sauna).state;
          float target = id(target_humidity).state;
          float dry_tol = id(hygrostat_dry_tolerance).state;
          float wet_tol = id(hygrostat_wet_tolerance).state;

          if (current < target - dry_tol) {
            id(saunaverdampfer).turn_on();
          } else if (current > target + wet_tol) {
            id(saunaverdampfer).turn_off();
          }
  # Auto-Off nach 4 Stunden
  - interval: 10s
    then:
      - lambda: |-
          bool session_active =
            (id(sauna_thermostat).mode != CLIMATE_MODE_OFF) ||
            id(hygrostat_active);

          if (session_active && id(sauna_session_start_time) == 0) {
            // Session startet jetzt
            id(sauna_session_start_time) = millis();
          }
          else if (!session_active) {
            // Session manuell beendet
            id(sauna_session_start_time) = 0;
          }
          else if (id(sauna_session_start_time) != 0) {
            // Session läuft - Timeout prüfen
            unsigned long elapsed = millis() - id(sauna_session_start_time);
            if (elapsed >= 4UL * 60 * 60 * 1000) {
              // 4h erreicht - Abschalten
              id(log_shutdown_auto_off_4h).execute();
              auto call = id(sauna_thermostat).make_call();
              call.set_mode("OFF");
              call.perform();
              id(hygrostat_switch).turn_off();
              id(sauna_session_start_time) = 0;
            }
          }
  # SSR-Sicherheit: Notabschaltung bei Schaltschrank-Übertemperatur
  # Schützt vor Überhitzung der SSRs und Brandgefahr im Holzständerhaus
  - interval: 5s
    then:
      - lambda: |-
          if (!id(temperatur_steuergeraet).has_state()) {
            return;
          }
          float temp = id(temperatur_steuergeraet).state;

          // Kritische Temperatur: 60°C - Ofen und Verdampfer abschalten
          if (temp >= 60.0 && !id(ssr_notabschaltung_aktiv)) {
            ESP_LOGW("ssr_safety", "KRITISCH: Schaltschrank %.1f°C - Notabschaltung!", temp);
            id(log_shutdown_ssr_uebertemp).execute();
            id(ssr_notabschaltung_aktiv) = true;

            // Thermostat abschalten
            auto call = id(sauna_thermostat).make_call();
            call.set_mode("OFF");
            call.perform();

            // Hygrostat abschalten
            id(hygrostat_switch).turn_off();
          }

          // Entwarnung bei <50°C - Notabschaltung zurücksetzen
          if (temp < 50.0 && id(ssr_notabschaltung_aktiv)) {
            ESP_LOGI("ssr_safety", "Entwarnung: Schaltschrank %.1f°C - Notabschaltung aufgehoben", temp);
            id(ssr_notabschaltung_aktiv) = false;
          }
  # Sauna-Sicherheit: Notabschaltung bei Sauna-Übertemperatur
  # Schützt vor Reglerversagen und zu hohen Temperaturen
  - interval: 5s
    then:
      - lambda: |-
          if (!id(temperatur_sauna).has_state()) {
            return;
          }
          float temp = id(temperatur_sauna).state;

          // Kritische Temperatur: 95°C - Ofen abschalten
          if (temp >= 95.0 && !id(sauna_notabschaltung_aktiv)) {
            ESP_LOGW("sauna_safety", "KRITISCH: Sauna %.1f°C - Notabschaltung!", temp);
            id(log_shutdown_sauna_uebertemp).execute();
            id(sauna_notabschaltung_aktiv) = true;

            // Thermostat abschalten
            auto call = id(sauna_thermostat).make_call();
            call.set_mode("OFF");
            call.perform();

            // Hygrostat abschalten (Verdampfer erzeugt auch Wärme)
            id(hygrostat_switch).turn_off();
          }

          // Entwarnung bei <85°C - Notabschaltung zurücksetzen
          if (temp < 85.0 && id(sauna_notabschaltung_aktiv)) {
            ESP_LOGI("sauna_safety", "Entwarnung: Sauna %.1f°C - Notabschaltung aufgehoben", temp);
            id(sauna_notabschaltung_aktiv) = false;
          }
  # Sensor-Ausfall Erkennung: Kein Temperaturwert seit 90s (3x 30s SHT30 Update-Interval)
  # Schützt vor defekten oder abgesteckten Sensoren (SHT30 Update-Interval: 30s)
  - interval: 10s
    then:
      - lambda: |-
          // Nur prüfen wenn Ofen oder Verdampfer aktiv
          bool heizung_aktiv = id(saunaofen).state || id(saunaverdampfer).state;
          if (!heizung_aktiv) {
            // Entwarnung wenn Heizung aus
            if (id(sensor_ausfall_aktiv)) {
              ESP_LOGI("sensor_safety", "Entwarnung: Heizung aus - Sensor-Ausfall zurückgesetzt");
              id(sensor_ausfall_aktiv) = false;
            }
            return;
          }

          // Prüfen ob Sensor-Daten zu alt (>270s = 3x Update-Interval von 90s)
          unsigned long jetzt = millis();
          unsigned long letztes_update = id(letzter_temperatur_update);

          // Schutz vor millis()-Überlauf und Erststart
          if (letztes_update == 0) {
            return;
          }

          unsigned long timeout = 90000;  // 90 Sekunden (3x 30s Update-Interval)
          if ((jetzt - letztes_update) > timeout && !id(sensor_ausfall_aktiv)) {
            ESP_LOGW("sensor_safety", "KRITISCH: Kein Temperaturwert seit >90s - Notabschaltung!");
            id(log_shutdown_sht30_ausfall).execute();
            id(sensor_ausfall_aktiv) = true;

            // Thermostat abschalten
            auto call = id(sauna_thermostat).make_call();
            call.set_mode("OFF");
            call.perform();

            // Hygrostat abschalten
            id(hygrostat_switch).turn_off();
          }

          // Entwarnung wenn Sensor wieder Daten liefert
          if ((jetzt - letztes_update) < timeout && id(sensor_ausfall_aktiv)) {
            ESP_LOGI("sensor_safety", "Entwarnung: Temperatursensor wieder aktiv");
            id(sensor_ausfall_aktiv) = false;
          }
  # DS18B20 Sensor-Ausfall Erkennung: Kein Schaltschrank-Temperaturwert seit 180s
  # Kritisch für SSR-Sicherheit - ohne Sensor kann Übertemperatur nicht erkannt werden
  # Dallas-Sensor Standard-Update-Interval: 60s, Timeout: 180s (3x Interval)
  - interval: 10s
    then:
      - lambda: |-
          // Nur prüfen wenn Ofen oder Verdampfer aktiv
          bool heizung_aktiv = id(saunaofen).state || id(saunaverdampfer).state;
          if (!heizung_aktiv) {
            // Entwarnung wenn Heizung aus
            if (id(ds18b20_ausfall_aktiv)) {
              ESP_LOGI("ds18b20_safety", "Entwarnung: Heizung aus - DS18B20-Ausfall zurückgesetzt");
              id(ds18b20_ausfall_aktiv) = false;
            }
            return;
          }

          // Prüfen ob Sensor-Daten zu alt (>180s = 3x Update-Interval)
          unsigned long jetzt = millis();
          unsigned long letztes_update = id(letzter_ds18b20_update);

          // Schutz vor millis()-Überlauf und Erststart
          if (letztes_update == 0) {
            return;
          }

          unsigned long timeout = 180000;  // 180 Sekunden (3x 60s Standard-Interval)
          if ((jetzt - letztes_update) > timeout && !id(ds18b20_ausfall_aktiv)) {
            ESP_LOGW("ds18b20_safety", "KRITISCH: Kein Schaltschrank-Temperaturwert seit >180s - Notabschaltung!");
            id(log_shutdown_ds18b20_ausfall).execute();
            id(ds18b20_ausfall_aktiv) = true;

            // Thermostat abschalten
            auto call = id(sauna_thermostat).make_call();
            call.set_mode("OFF");
            call.perform();

            // Hygrostat abschalten
            id(hygrostat_switch).turn_off();
          }

          // Entwarnung wenn Sensor wieder Daten liefert
          if ((jetzt - letztes_update) < timeout && id(ds18b20_ausfall_aktiv)) {
            ESP_LOGI("ds18b20_safety", "Entwarnung: DS18B20 Sensor wieder aktiv");
            id(ds18b20_ausfall_aktiv) = false;
          }
  # Infrarot Auto-Off nach 2 Stunden
  # Verhindert vergessene Infrarotstrahler
  - interval: 10s
    then:
      - lambda: |-
          unsigned long jetzt = millis();
          unsigned long max_time = 2UL * 60 * 60 * 1000;  // 2h in ms

          // Infrarot 1 prüfen
          if (id(infrarot1_start_ms) != 0) {
            unsigned long elapsed = jetzt - id(infrarot1_start_ms);
            if (elapsed >= max_time) {
              ESP_LOGI("infrarot_safety", "Auto-Off: Infrarot 1 nach 2h abgeschaltet");
              id(infrarot1).turn_off();
            }
          }

          // Infrarot 2 prüfen
          if (id(infrarot2_start_ms) != 0) {
            unsigned long elapsed = jetzt - id(infrarot2_start_ms);
            if (elapsed >= max_time) {
              ESP_LOGI("infrarot_safety", "Auto-Off: Infrarot 2 nach 2h abgeschaltet");
              id(infrarot2).turn_off();
            }
          }
  # LED Anti-Flacker: Periodisches Refresh-Signal
  # WS2812 LEDs brauchen regelmäßige Refresh-Signale auch wenn aus,
  # sonst interpretieren sie nach Stunden akkumuliertes Rauschen als Farbbefehle
  - interval: 60s
    then:
      - lambda: |-
          // Nur refreshen wenn LEDs aus sind
          if (!id(led_salzkristall).remote_values.is_on()) {
            auto call = id(led_salzkristall).turn_off();
            call.perform();
          }
          if (!id(led_streifen).remote_values.is_on()) {
            auto call = id(led_streifen).turn_off();
            call.perform();
          }
